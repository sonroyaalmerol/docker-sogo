package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
	"howett.net/plist"
)

const (
	defaultConfigFolder = "/etc/sogo/sogo.conf.d/"
	defaultConfigPath   = "/etc/sogo/sogo.conf"
)

const disclaimerMessage = `/* *********************  Main SOGo configuration file  **********************
 *                                                                           *
 * This configuration is AUTOGENERATED by the Docker container based on the  *
 * YAML files provided in /etc/sogo/sogo.conf.d/.                            *
 *                                                                           *
 * YAML configurations is only applicable for this specific container.       *
 *                                                                           *
 * The script inside the container merges the YAML files in the directory    *
 * and converts the merged config into OpenStep plist format.                *
 *                                                                           *
 * Since the content of this file is a dictionary in OpenStep plist format,  *
 * the curly braces enclosing the body of the configuration are mandatory.   *
 * See the Installation Guide for details on the format.                     *
 *                                                                           *
 * C and C++ style comments are supported.                                   *
 *                                                                           *
 * This example configuration contains only a subset of all available        *
 * configuration parameters. Please see the installation guide more details. *
 *                                                                           *
 * ~sogo/GNUstep/Defaults/.GNUstepDefaults has precedence over this file,    *
 * make sure to move it away to avoid unwanted parameter overrides.          *
 *                                                                           *
 * **************************************************************************/`

func deepMergeMaps(dst, src map[string]interface{}) map[string]interface{} {
	if dst == nil {
		dst = make(map[string]interface{})
	}
	for key, srcVal := range src {
		if dstVal, ok := dst[key]; ok {
			if srcMap, srcOk := srcVal.(map[string]interface{}); srcOk {
				if dstMap, dstOk := dstVal.(map[string]interface{}); dstOk {
					dst[key] = deepMergeMaps(dstMap, srcMap)
					continue
				}
			}
		}
		dst[key] = srcVal
	}
	return dst
}

// generateConfigFile now accepts paths as arguments
func generateConfigFile(configFolder, outputPath string) error {
	if err := os.MkdirAll(configFolder, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", configFolder, err)
	}

	ymlFiles, err := filepath.Glob(filepath.Join(configFolder, "*.yml"))
	if err != nil {
		return fmt.Errorf("failed to search for .yml files: %w", err)
	}
	for _, ymlFile := range ymlFiles {
		yamlFile := strings.TrimSuffix(ymlFile, ".yml") + ".yaml"
		// Log renaming for tests, but don't print during normal operation
		// fmt.Printf("Renaming %s to %s\n", ymlFile, yamlFile)
		if err := os.Rename(ymlFile, yamlFile); err != nil {
			// Check if the error is because the target exists (e.g., race in tests)
			// If it exists, we can probably ignore the error.
			if !os.IsExist(err) {
				return fmt.Errorf("failed to rename %s to %s: %w", ymlFile, yamlFile, err)
			}
		}
	}

	yamlFiles, err := filepath.Glob(filepath.Join(configFolder, "*.yaml"))
	if err != nil {
		return fmt.Errorf("failed to search for .yaml files: %w", err)
	}
	sort.Strings(yamlFiles)

	mergedData := make(map[string]interface{})
	foundValidData := false // Track if we actually merged anything
	for _, file := range yamlFiles {
		yamlContent, err := os.ReadFile(file)
		if err != nil {
			log.Printf("Warning: Failed to read YAML file %s: %v. Skipping.", file, err)
			continue
		}
		var currentData map[string]interface{}
		if err := yaml.Unmarshal(yamlContent, &currentData); err != nil {
			if len(strings.TrimSpace(string(yamlContent))) == 0 {
				log.Printf("Info: Skipping empty YAML file %s", file)
				continue
			}
			log.Printf("Warning: Failed to parse YAML file %s: %v. Skipping.", file, err)
			continue
		}
		if currentData == nil || len(currentData) == 0 {
			log.Printf("Info: Skipping empty YAML file %s", file)
			continue
		}
		mergedData = deepMergeMaps(mergedData, currentData)
		foundValidData = true
	}

	// Create/Truncate config file
	outFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create config file %s: %w", outputPath, err)
	}
	defer outFile.Close()

	// Write disclaimer first
	_, err = io.WriteString(outFile, disclaimerMessage+"\n\n")
	if err != nil {
		return fmt.Errorf("failed to write disclaimer to config file: %w", err)
	}

	// Handle case where no valid data was found
	if !foundValidData {
		log.Println("Warning: No valid YAML data found or merged result is empty.")
		// Write the specific empty plist structure expected by tests
		_, err = io.WriteString(outFile, "{\n  /* No configuration loaded from YAML files. */\n}\n")
		if err != nil {
			return fmt.Errorf("failed to write empty config block to %s: %w", outputPath, err)
		}
		// Sync file contents to disk even for empty file
		if syncErr := outFile.Sync(); syncErr != nil {
			// Log sync error but return the write error if it occurred
			log.Printf("Warning: failed to sync empty config file %s: %v", outputPath, syncErr)
		}
		return err // Return potential write error or nil
	}

	// Use howett.net/plist for output if we have data
	encoder := plist.NewEncoderForFormat(outFile, plist.OpenStepFormat)
	encoder.Indent("  ")

	err = encoder.Encode(mergedData)
	if err != nil {
		// Close might fail, but prioritize the encode error
		outFile.Close()
		return fmt.Errorf("failed to encode data to plist format: %w", err)
	}

	// Add a final newline for better formatting
	_, err = fmt.Fprintln(outFile)
	if err != nil {
		log.Printf("Warning: Failed to write final newline: %v", err)
	}

	if err := outFile.Sync(); err != nil {
		return fmt.Errorf("failed to sync config file %s: %w", outputPath, err)
	}

	return nil
}

func main() {
	if err := generateConfigFile(defaultConfigFolder, defaultConfigPath); err != nil {
		log.Fatalf("Error generating SOGo configuration: %v", err)
	}

	fmt.Printf("SOGo configuration generated successfully at %s\n", defaultConfigPath)
}
