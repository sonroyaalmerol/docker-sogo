diff --git a/SoObjects/SOGo/SOGoUserManager.m b/SoObjects/SOGo/SOGoUserManager.m
--- SoObjects/SOGo/SOGoUserManager.m
+++ SoObjects/SOGo/SOGoUserManager.m
@@ -691,17 +691,14 @@
                                          forLogin: username];
         }
     }
 
-  // We check for cached passwords. If the entry is cached, we
-  // check this immediately. If not, we'll go directly at the
-  // authentication source and try to validate there, then cache it.
+  // Do not rely on cached password hashes. We may still read user attributes,
+  // but we will not use any cached "password" field to short-circuit auth.
   jsonUser = [[SOGoCache sharedCache] userAttributesForLogin: username];
   currentUser = [jsonUser objectFromJSONString];
+  if ([currentUser isKindOfClass: NSNullK]) currentUser = nil;
 
-  if ([currentUser isKindOfClass: NSNullK])
-    currentUser = nil;
-
   //
   // If we are using multidomain and the UIDFieldName is not part of the email address
   // we must bind without the domain part since internally, SOGo will use
   // UIDFieldName @ domain as its unique identifier if the UIDFieldName is used to
@@ -721,27 +718,19 @@
       r = [_login rangeOfString: [NSString stringWithFormat: @"@%@", *_domain]];
       _login = [_login substringToIndex: r.location];
     }
 
-  dictPassword = (currentUser ? [currentUser objectForKey: @"password"] : nil);
-  if (useCache && currentUser && dictPassword)
-    {
-      checkOK = ([dictPassword isEqualToString: [_pwd asSHA1String]]);
-      //NSLog(@"Password cache hit for user %@", _login);
-    }
-  else if ([self _sourceCheckLogin: _login
+  // Always validate against the real authentication source; never accept cache.
+  if ([self _sourceCheckLogin: _login
                        andPassword: _pwd
                             domain: _domain
                               perr: _perr
                             expire: _expire
                              grace: _grace
                     additionalInfo: _additionalInfo])
     {
       checkOK = YES;
-      if (!currentUser)
-        {
-          currentUser = [NSMutableDictionary dictionary];
-        }
+      if (!currentUser) currentUser = [NSMutableDictionary dictionary];
 
       // Before caching user attributes, we must check if SOGoEnableDomainBasedUID is enabled
       // but we don't have a domain. That would happen for example if the user authenticates
       // without the domain part. We must also cache that information, since SOGo will try
@@ -753,17 +742,13 @@
           username = [NSString stringWithFormat: @"%@@%@", username, *_domain];
           [currentUser setObject: [NSNumber numberWithBool: YES]  forKey: @"DomainLessLogin"];
         }
 
-      // It's important to cache the password here as we might have cached the
-      // user's entry in -contactInfosForUserWithUIDorEmail: and if we don't
-      // set the password and recache the entry, the password would never be
-      // cached for the user unless its entry expires from memcached's
-      // internal cache.
-      [currentUser setObject: [_pwd asSHA1String] forKey: @"password"];
-      [[SOGoCache sharedCache]
-        setUserAttributes: [currentUser jsonRepresentation]
-                 forLogin: username];
+      // Do NOT cache password. Remove any existing cached 'password'.
+      if ([currentUser objectForKey: @"password"])
+        [currentUser removeObjectForKey: @"password"];
+      [[SOGoCache sharedCache] setUserAttributes: [currentUser jsonRepresentation]
+                                        forLogin: username];
     }
   else
     {
       // If failed login "rate-limiting" is enabled, we adjust the stats
@@ -851,14 +836,12 @@
 
       if (!currentUser)
         currentUser = [NSMutableDictionary dictionary];
 
-      // It's important to cache the password here as we might have cached the
-      // user's entry in -contactInfosForUserWithUIDorEmail: and if we don't
-      // set the password and recache the entry, the password would never be
-      // cached for the user unless its entry expires from memcached's
-      // internal cache.
-      [currentUser setObject: [newPassword asSHA1String] forKey: @"password"];
+      if (!currentUser) currentUser = [NSMutableDictionary dictionary];
+      // Do not cache password hashes; remove if present.
+      if ([currentUser objectForKey: @"password"])
+        [currentUser removeObjectForKey: @"password"];
       sd = [SOGoSystemDefaults sharedSystemDefaults];
       if ([sd enableDomainBasedUID] &&
           [login rangeOfString: @"@"].location == NSNotFound)
         userLogin = [NSString stringWithFormat: @"%@@%@", login, domain];
