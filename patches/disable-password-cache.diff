diff --git a/SoObjects/SOGo/SOGoUserManager.m b/SoObjects/SOGo/SOGoUserManager.m
index 0000000..0000001 100644
--- a/SoObjects/SOGo/SOGoUserManager.m
+++ b/SoObjects/SOGo/SOGoUserManager.m
@@ -1,3 +1,4 @@
+/* Patch: disable password caching in checkLogin and changePassword flows */
 /* SOGoUserManager.m - this file is part of SOGo
  *
  * Copyright (C) 2007-2021 Inverse inc.
@@ -430,36 +431,27 @@
            useCache: (BOOL) useCache
 {
   NSString *dictPassword, *username, *jsonUser;
   NSMutableDictionary *currentUser;
   NSDictionary *failedCount;
   SOGoSystemDefaults *sd;
   BOOL checkOK;

   if (!_login)
     return NO;

   sd = [SOGoSystemDefaults sharedSystemDefaults];

   username = _login;

   /* ... unchanged code above ... */

-  // We check for cached passwords. If the entry is cached, we
-  // check this immediately. If not, we'll go directly at the
-  // authentication source and try to validate there, then cache it.
-  jsonUser = [[SOGoCache sharedCache] userAttributesForLogin: username];
-  currentUser = [jsonUser objectFromJSONString];
-
-  if ([currentUser isKindOfClass: NSNullK])
-    currentUser = nil;
+  // Do not rely on cached password hashes. We may still read user attributes,
+  // but we will not use any cached "password" field to short-circuit auth.
+  jsonUser = [[SOGoCache sharedCache] userAttributesForLogin: username];
+  currentUser = [jsonUser objectFromJSONString];
+  if ([currentUser isKindOfClass: NSNullK]) currentUser = nil;

   //
   // If we are using multidomain and the UIDFieldName is not part of the email address
   // we must bind without the domain part since internally, SOGo will use
   // UIDFieldName @ domain as its unique identifier if the UIDFieldName is used to
   // authenticate. This can happen for example of one has in LDAP:
   //
   // dn: uid=foo,dc=example,dc=com
   // uid: foo
   // mail: broccoli@example.com
   //
   // and authenticates with "foo", using bindFields = (uid, mail) and SOGoEnableDomainBasedUID = YES;
   // Otherwise, -_sourceCheckLogin:... would have failed because SOGo would try to bind using: foo@example.com
   //
   if (currentUser && [[currentUser objectForKey: @"DomainLessLogin"] boolValue])
     {
       NSRange r;

       r = [_login rangeOfString: [NSString stringWithFormat: @"@%@", *_domain]];
       _login = [_login substringToIndex: r.location];
     }

-  dictPassword = (currentUser ? [currentUser objectForKey: @"password"] : nil);
-  if (useCache && currentUser && dictPassword)
-    {
-      checkOK = ([dictPassword isEqualToString: [_pwd asSHA1String]]);
-      //NSLog(@"Password cache hit for user %@", _login);
-    }
-  else if ([self _sourceCheckLogin: _login
+  // Always validate against the real authentication source; never accept cache.
+  if ([self _sourceCheckLogin: _login
                        andPassword: _pwd
                             domain: _domain
                               perr: _perr
                             expire: _expire
                              grace: _grace
                     additionalInfo: _additionalInfo])
     {
       checkOK = YES;
-      if (!currentUser)
-        {
-          currentUser = [NSMutableDictionary dictionary];
-        }
+      if (!currentUser) currentUser = [NSMutableDictionary dictionary];

       // Before caching user attributes, we must check if SOGoEnableDomainBasedUID is enabled
       // but we don't have a domain. That would happen for example if the user authenticates
       // without the domain part. We must also cache that information, since SOGo will try
       // afterward to bind with UIDFieldName@domain, and it could potentially not exist
       // in the authentication source. See the rationale in _sourceCheckLogin: ...
       if ([sd enableDomainBasedUID] &&
           [username rangeOfString: @"@"].location == NSNotFound)
         {
           username = [NSString stringWithFormat: @"%@@%@", username, *_domain];
           [currentUser setObject: [NSNumber numberWithBool: YES]  forKey: @"DomainLessLogin"];
         }

-      // It's important to cache the password here as we might have cached the
-      // user's entry in -contactInfosForUserWithUIDorEmail: and if we don't
-      // set the password and recache the entry, the password would never be
-      // cached for the user unless its entry expires from memcached's
-      // internal cache.
-      [currentUser setObject: [_pwd asSHA1String] forKey: @"password"];
-      [[SOGoCache sharedCache]
-        setUserAttributes: [currentUser jsonRepresentation]
-                 forLogin: username];
+      // Do NOT cache password hashes. Remove any existing cached 'password'.
+      if ([currentUser objectForKey:@"password"])
+        [currentUser removeObjectForKey:@"password"];
+      [[SOGoCache sharedCache] setUserAttributes:[currentUser jsonRepresentation]
+                                        forLogin:username];
     }
   else
     {
       // If failed login "rate-limiting" is enabled, we adjust the stats
       if ([sd maximumFailedLoginCount])
         {
           [[SOGoCache sharedCache] setFailedCount: ([[failedCount objectForKey: @"FailedCount"] intValue] + 1)
                                          forLogin: username];
         }

       checkOK = NO;
     }

   // We MUST, for all LDAP sources, update the bindDN and bindPassword
   // to the user's value if bindAsCurrentUser is set to true in the
   // LDAP source configuration.
   //
   // We also update the baseDN of all sources.
   if (checkOK)
     {
       NSObject <SOGoDNSource> *currentSource;
       NSEnumerator *sources;

       sources = [[_sources allValues] objectEnumerator];
       while ((currentSource = [sources nextObject]))
         if ([currentSource conformsToProtocol: @protocol(SOGoDNSource)] &&
             [currentSource bindAsCurrentUser] &&
             [currentSource lookupDNByLogin: _login])
           {
             [currentSource setBindDN: [currentSource lookupDNByLogin: _login]];
             [currentSource setBindPassword: _pwd];
             [currentSource updateBaseDNFromLogin: _login];
           }
     }

   return checkOK;
 }
@@ -596,25 +588,19 @@
       didChange = YES;

-      if (!currentUser)
-        currentUser = [NSMutableDictionary dictionary];
-
-      // It's important to cache the password here as we might have cached the
-      // user's entry in -contactInfosForUserWithUIDorEmail: and if we don't
-      // set the password and recache the entry, the password would never be
-      // cached for the user unless its entry expires from memcached's
-      // internal cache.
-      [currentUser setObject: [newPassword asSHA1String] forKey: @"password"];
+      if (!currentUser) currentUser = [NSMutableDictionary dictionary];
+      // Do not cache password hashes; remove if present.
+      if ([currentUser objectForKey:@"password"])
+        [currentUser removeObjectForKey:@"password"];
       sd = [SOGoSystemDefaults sharedSystemDefaults];
       if ([sd enableDomainBasedUID] &&
           [login rangeOfString: @"@"].location == NSNotFound)
         userLogin = [NSString stringWithFormat: @"%@@%@", login, domain];
       else
         userLogin = login;
       [[SOGoCache sharedCache] setUserAttributes: [currentUser jsonRepresentation]
                                         forLogin: userLogin];
     }
     else
       didChange = NO;

   return didChange;
 }